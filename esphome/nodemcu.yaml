substitutions:
# FIXME: adjust
  unit_name: nodemcu

wifi:
  # FIXME: adjust
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  reboot_timeout: 0s

# I'm using mqtt for communication with home assistant. esphome native api is also possible, see lilygo-c3 branch
mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password

esphome:
  name: ${unit_name}
  friendly_name: ${unit_name}
  on_boot:
    then:
      # optionally reboot arduino when this device is rebooted
      - switch.turn_on: arduino_reset

# esp32 is also possible, see lilygo-c3 branch. any board with UART should work in theory.
esp8266:
  board: nodemcuv2 # FIXME: adjust to your board
  early_pin_init: False # don't mess with gpio pins on boot

logger:
  # move esphome's logger to UART1 since we use UART0 for communcation with the arduino
  hardware_uart: UART1 
  # disable hardware logging
  baud_rate: 0
  level: INFO

globals:
# global variable for the hostmachine power state
  - id: last_host_state
    type: std::string
    restore_value: no
    initial_value: ""

# library for serial port communication with the arduino board
external_components:
  - source: github://eigger/espcomponents@latest # https://github.com/eigger/espcomponents/tree/master/components/uartex
    components:
      - uartex
uartex:
  rx_footer: "\r\n"

# serial port for arduino
uart:
  id: ducky
  tx_pin: TX
  rx_pin: RX
  baud_rate: 115200

# optional
# status_led:
#   pin:
#     number: GPIO2
#     inverted: true

# sensor:
  # - platform: wifi_signal
  #   name: ${unit_name}_signal
  #   update_interval: 60s

# optional arduino reset pin
switch:
  - platform: gpio
    pin: 
      number: D4
      inverted: True
    id: arduino_reset
    on_turn_on:
      - delay: 50ms
      - switch.turn_off: arduino_reset

text_sensor:
  # feedback from arduino
  - platform: template
    name: ${unit_name}_response
    id: ducky_response
    on_value:
      - logger.log:
          level: INFO
          format: "ducky_response: %s"
          args: ['x.c_str()']

  # host machine's usb port power state
  - platform: template
    id: ducky_host_state
    name: ${unit_name}_host_state

  # host machine's usb serial input forwarding
  - platform: template
    id: ducky_usb_input
    name: ${unit_name}_usb_input
  
  # topic for message reception
  - platform: mqtt_subscribe
    id: ducky_request
    topic: esphome/${unit_name}/run
    retain: false
    on_value:
      then:
        - if:
            condition:
              # ignore empty messages
              lambda: |-
                return ((x.length() > 0) && (x != "\n"));
            then:
              - logger.log:
                  level: INFO
                  format: "ducky_request: %s"
                  args: ['x.c_str()']
              - uart.write: 
                  id: ducky
                  # encapsulate message with STX and ETX chars and write to serial port
                  data: !lambda |-
                    char stx = 0x02;
                    char etx = 0x03;
                    std::string s = stx + x + etx;
                    return std::vector<unsigned char>(s.begin(),s.end());

  # serial port back channel from the arduino
  - platform: uartex
    id: read_line_sensor
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data), len);
    on_value:
      then:
        - if:
            condition:
              # usb power state
              lambda: |-
                return str_startswith(x, "STATE=");
            then:
              - globals.set:
                  id: last_host_state
                  value: !lambda |-
                    x.erase(0,6);
                    return x.c_str();
              - if:
                  condition:
                    lambda: |-
                      return (id(last_host_state) != id(ducky_host_state).state);
                  then:
                    - text_sensor.template.publish:
                        id: ducky_host_state
                        state: !lambda |-
                          return id(last_host_state);
        - if:
            condition:
              # usb serial input forwarding
              lambda: |-
                return str_startswith(x, "USB_INPUT=");
            then:
              - text_sensor.template.publish:
                  id: ducky_usb_input
                  state: !lambda |-
                    x.erase(0,10);
                    return x.c_str();
            else:
              # responses (ready/busy etc.)
              - if:
                  condition:
                    lambda: |-
                      return (x != id(ducky_response).state);
                  then:
                    - text_sensor.template.publish:
                        id: ducky_response
                        state: !lambda |-
                          return x;
